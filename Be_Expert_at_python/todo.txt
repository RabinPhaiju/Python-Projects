Generators context managers and decorators. It does it requiring that you know a little bit of the details of how each of these work but fundamentally what we can see is what we have here is three features with very clear conceptual meaning. Orthogonal conceptual meaning where each of those pieces of conceptual meaning kind of fit together a context manager is merely some piece of code that pairs set up and tear down actions so that the tear down action always occurs if the setup action occurred. 
I generator is merely some form of syntax that allows us to do things like enforce sequencing and interleaving notice the context manager requires interleaving because the setup is interleaved with the actual action you do in the block you do the setup then the action in the block then the tear down at the end there is that sequencing where the setup the enter has to be done before the exit so it makes sense to have a generator here as well. 

Finally we need some thing to adapt the generator to this data model that we looked at at the very beginning we have these _ methods and we have to find some way to take how the generator works and fit it into those. _ methods. 

One of the things we need to do in order to do that is we need to take this generator object to wrap it in some fashion. That wrap. The core of how Python works it's easy to dynamically construct functions and have those functions wrap other functions that's part of the core language itself, it's not really something that we could even lift to the level of being a feature it really is core to how Python itself is written. 

However there does happen to be a feature called decorators that allows us a nice convenient syntax for doing that exactly so what you can see here is an example of everything except metaclasses and how they all fit together and how some of these core pieces of Python fit together to write what you might consider to be. 

More nearly expert level code. What I can tell you is that in Python expert level code is not code that uses every single feature it's in fact not code that even uses that many features of Python it's code that has a certain clarity to where and when a feature should be used it's code that doesn't waste the time of the person who's writing it because they say to themselves. 

I have this pattern Python has this mechanism I fit them together and everything just seamlessly and and and very smoothly works. It's code that doesn't have. Additional mechanisms associated with it doesn't have people creating their own protocols, it doesn't have people creating their own frameworks where the language itself provides the core pieces that you need and you merely have to understand what those core pieces are what they mean and how to assemble them so over the last 90 minutes. 

I've showed you. Couple of details of how Python itself is designed and four features that you've probably heard of that. Python is known for Four features that you might associate with features that an expert would know. Or at least if you go and interview for a Python job and you say I'm an expert Python programmer these are four features that you're going to be asked about more likely. 

The question here is does anybody remember any of the syntax they looked at probably not even I don't remember it and I'm giving the talk and I have cheat. I have notes here. I have like a cheat sheet. The real answer here is the notes the the details, they do matter they matter very much you can't write the code unless you know this syntax the code won't compile it won't run. 

However, what is far more important than the names of the arguments that can pass to exit or the specific fashion in which difference numeric underscore methods get dispatched, whether you do our ad or our ad. 

Depending on which is the most arrived class. All of those details are actually secondary to a core conceptual understanding of what these feature me what these features mean. So what I can tell you as the real lessons. Of this session where as follows Python is a language orientated around protocols. 

There's some behavior some syntax some byte code or some top-level function and there's a way for you to tell Python how to implement that on an arbitrary object via. _ methods. That exact correspondence is usually guessable, but if you can't guess it Google Python data model and you'll find all the different methods and all the caveats of their use. 

Python is a very simple simplistic language in terms of its execution model. Code runs from top to bottom and things which would not be executable statements other languages, like class statements and function definitions or generate definitions are actually executable code in Python. Because they're executable code not only can you do things like hook into them, but you can also do things like define functions within functions based off runtime data. 

Define classes within functions based off of some runtime information you have. How these impact specific features metaclasses metaclasses merely some hook into a class construction process. Because classes are constructed at runtime you can hook code in there and because you can hook into the creation of subclasses you can ask the subclass certain questions like do you have these methods do have these methods implemented? 

That's what they do. That's the mechanism but the meaning behind it is quite simple. You have library code and user code When you sit on the library author side, how do you make sure the users don't screw up? How do you enforce a constraint from the library code to the user code? 

Well, all that it takes is some way took into the process of how user code user classes are instantiated. That's familiar with the metaclasses. You find that place where you add that hook, you add the check that you want. Oh, make sure that you have the bar method in implemented. 

And you solve the problem. In fact in the Python standard library, there are. Regularized solutions the problems like that then collections that ABC there is an ABC meta class allows you to use decorators to mark certain methods that abstract methods, so you don't have to write the meta class yourself. 

And you can think this is a pattern of what the medical class is doing in fact almost every example of a meta class that you'll see will be this pattern of some bass class and some derived class the bass class trying to enforce a constraint on the drive class, it's almost every pattern of the metaclass that you'll see where that metaclass is, it justified, of course, you can misuse them to do all sorts of crazy things you can use them in places where it doesn't make any sense but in the justified uses of the metaclass that's what it's all about. 

For the decorator it really isn't anything that interesting just a little bit of syntax to allow you to write one line of code a little bit nicer to take one line of code that you write after your function definition and put it above your function definition at runtime so that when you combine that with the ability to define functions within functions, you can use this in order to wrap sets a functions with some before and after behavior if you're been around long enough, you might think you might recall, this was the whole aspect orientated idea, but the idea that Can I take a function and wrap it with some behavior such as timing, you know, capturing the type before captioning the time after or doing things like authentication or logging anything where you don't have to go into the function itself, you just wrap the behavior around. 

Generators are merely away to take a single computation that would otherwise run eagerly from the uncertain from the injection of its parameters to the final computation and interleave with other code by adding yield points where you can yield. The the intermediate result values or one small piece of the computation and also yield control back to the collar. 

In that vein you can think of a generator as being a way to take one long piece of one long computation and break it up in small parts where the computation can run a small subunit of that computation that your user code can step into wherever it wants maybe it will use a partial value or use one of the first return values if you're returning a sequence of return values, you might use the each of the individual values and in that fashion you can have greater control over how much of that how much of that computation actually runs, do you run it all the way to completion or do you need to run it to gap the first? 

Five values you need you also have greater control over how much memory is used because the generic can just yield the values back to you and you can choose which of those return values you want to keep which of them you want to throw away. Context managers are merely some structure for allowing you to tie two actions together I set up action and a tear down action and make sure they always happen things accordance with each other if the setup actually occurs make sure that tear on action occurs even if some error happens and when you think about these features and you realize there were later but mostly orthogonal you can combine them interesting ways like you see in this example here where you have a decorator a context manner and a generator all coexisting and serving exactly it's one purpose. 

As I said at the very beginning the syntax doesn't matter the details won't matter until you need to use them what I want to leave you with especially since a lot of you are not already very fluent. Python programmers. I want to leave you with this idea. Remember what these features are about remember what they're for that's something that you should be able to remember longer than the exact details of the syntax or even movement implementation details, in fact the implementation details and details and syntax will change over time some of the flaws are the implementation make it fixed other details will be fixed in other fashion. 

But the core meaning behind these is something that will last and will guide you towards writing expert level Python code far better than memorizing just a bunch of features everywhere, so that's why presentation. I hope you enjoyed it, thank you very much for being a part of it.